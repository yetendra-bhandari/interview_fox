const crypto = require("crypto");
const jwt = require("jsonwebtoken");
const { ObjectID } = require("mongodb");
const { getUserChannels, userHasApplied } = require("./helper");

// Randomly generated bytes using "crypto.randomBytes()"
const PRIVATE_KEY =
  "0199bc37659a9143230b63a9c38569b83b2c55c84820f407e0629a78cff4f1b23a6366bffdddbcc7148c2d5b73c92f6a9b2c5d2abdcd73d9bb9b26b26feedc2a";

async function emailExists(db, email) {
  try {
    return Boolean(
      await db
        .collection("users")
        .findOne({ email: email.trim().toLowerCase() })
    );
  } catch (err) {
    console.error(err);
    return false;
  }
}

function isValid(user) {
  try {
    return (
      (user.userType === "E" ||
        (user.userType === "B" && user.company.length <= 64)) &&
      user.name.length <= 64 &&
      user.email.length <= 64 &&
      user.phone.match(/^[0-9]{10}$/) &&
      Number.isInteger(new Date(user.dateOfBirth).getTime()) &&
      user.password.length >= 8 &&
      user.password.length <= 64 &&
      Array.isArray(user.skills) &&
      user.skills.every((skill) => typeof skill === "string")
    );
  } catch (err) {
    return false;
  }
}

async function registerUser(db, user, remember) {
  try {
    if (isValid(user)) {
      if (!(await emailExists(db, user.email))) {
        const salt = crypto.randomBytes(16).toString("hex");
        const derivedKey = crypto
          .scryptSync(user.password, salt, 64)
          .toString("hex");
        const result = await db.collection("users").insertOne({
          userType: user.userType,
          ...(user.userType === "B" && { company: user.company.trim() }),
          name: user.name.trim(),
          email: user.email.trim().toLowerCase(),
          phone: user.phone,
          dateOfBirth: user.dateOfBirth,
          skills: user.skills,
          salt: salt,
          passwordHash: derivedKey,
        });
        return {
          success: true,
          token: jwt.sign({ id: result.insertedId }, PRIVATE_KEY, {
            expiresIn: remember ? "7d" : "3h",
          }),
          expiresAt: new Date().getTime() + (remember ? 604800000 : 10800000),
          userID: result.insertedId,
          name: user.name,
          userType: user.userType,
        };
      } else {
        return { success: false, message: "Email Address Already Exists" };
      }
    } else {
      return { success: false, message: "Invalid Data Provided" };
    }
  } catch (err) {
    console.error(err);
    return {
      success: false,
      message: "An Error Occured. Please Try Again Later",
    };
  }
}

async function loginUser(db, user, remember) {
  try {
    const result = await db
      .collection("users")
      .findOne({ email: user.email.trim().toLowerCase() });
    if (result) {
      const derivedKey = crypto
        .scryptSync(user.password, result.salt, 64)
        .toString("hex");
      if (derivedKey === result.passwordHash) {
        return {
          success: true,
          token: jwt.sign({ id: result._id }, PRIVATE_KEY, {
            expiresIn: remember ? "7d" : "3h",
          }),
          expiresAt: new Date().getTime() + (remember ? 604800000 : 10800000),
          userID: result._id,
          name: result.name,
          userType: result.userType,
        };
      } else {
        return { success: false, message: "Wrong Password" };
      }
    } else {
      return {
        success: false,
        message: "Email Address Does Not Exist",
      };
    }
  } catch (err) {
    console.error(err);
    return {
      success: false,
      message: "An Error Occured. Please Try Again Later",
    };
  }
}

function getUserID(token) {
  try {
    return jwt.verify(token, PRIVATE_KEY).id;
  } catch (err) {
    console.error(err);
    return null;
  }
}

async function getUser(db, userID) {
  try {
    const user = await db
      .collection("users")
      .findOne(
        { _id: ObjectID(userID) },
        { projection: { salt: 0, passwordHash: 0 } }
      );
    if (user) {
      return {
        success: true,
        user: { ...user, channels: await getUserChannels(db, userID) },
      };
    } else {
      return {
        success: false,
        message: "User Does Not Exist",
      };
    }
  } catch (err) {
    console.error(err);
    return {
      success: false,
      message: "An Error Occured. Please Try Again Later",
    };
  }
}

async function getUserCompany(db, userID) {
  try {
    return (
      await db
        .collection("users")
        .findOne(
          { _id: ObjectID(userID), userType: "B" },
          { projection: { _id: 0, company: 1 } }
        )
    ).company;
  } catch (err) {
    console.error(err);
    return null;
  }
}

async function getUserSkills(db, userID) {
  try {
    const user = await db
      .collection("users")
      .findOne(
        { _id: ObjectID(userID) },
        { projection: { _id: 0, skills: 1 } }
      );
    if (user) {
      return {
        success: true,
        skills: user.skills,
      };
    }
  } catch (err) {
    console.error(err);
    return {
      success: false,
      message: "User Does Not Exist",
    };
  }
}

async function getUserType(db, userID) {
  try {
    return (
      await db
        .collection("users")
        .findOne(
          { _id: ObjectID(userID) },
          { projection: { _id: 0, userType: 1 } }
        )
    ).userType;
  } catch (err) {
    console.error(err);
    return null;
  }
}

async function patchUser(db, userID, skills) {
  try {
    if (
      Array.isArray(skills) &&
      skills.every((skill) => typeof skill === "string")
    ) {
      const result = await db.collection("users").updateOne(
        { _id: ObjectID(userID) },
        {
          $set: {
            skills: skills,
          },
        }
      );
      if (result.modifiedCount) {
        return {
          success: true,
          message: "User Details Updated Successfully",
        };
      } else {
        return {
          success: false,
          message: "User Does Not Exist",
        };
      }
    } else {
      return { success: false, message: "Invalid Data Provided" };
    }
  } catch (err) {
    console.error(err);
    return {
      success: false,
      message: "An Error Occured. Please Try Again Later",
    };
  }
}

async function getRecommendedCompanies(db, userID) {
  try {
    const user = await db
      .collection("users")
      .findOne(
        { _id: ObjectID(userID), userType: "E" },
        { projection: { _id: 0, skills: 1 } }
      );
    if (user) {
      const skills = user.skills;
      const applications = await db
        .collection("applications")
        .find(
          { applicant: ObjectID(userID) },
          { projection: { _id: 0, company: 1 } }
        )
        .toArray();
      const appliedCompanies = applications.map(
        (application) => application.company
      );
      const recommended = await db
        .collection("users")
        .aggregate([
          { $unwind: "$skills" },
          {
            $match: {
              $and: [
                { userType: "B" },
                { _id: { $nin: appliedCompanies } },
                { skills: { $in: skills } },
              ],
            },
          },
          {
            $group: {
              _id: "$_id",
              company: { $first: "$company" },
              skills: { $push: "$skills" },
              commonSkills: { $sum: 1 },
            },
          },
          { $sort: { commonSkills: -1 } },
          { $limit: 10 },
        ])
        .toArray();
      return {
        success: true,
        recommended: recommended,
      };
    } else {
      return {
        success: false,
        message: "Employee Does Not Exist",
      };
    }
  } catch (err) {
    console.error(err);
    return {
      success: false,
      message: "An Error Occured. Please Try Again Later",
    };
  }
}

async function searchCompany(db, userID, companyName) {
  try {
    const companies = await db
      .collection("users")
      .find(
        { userType: "B", company: new RegExp(companyName, "i") },
        { projection: { company: 1, skills: 1 } }
      )
      .toArray();
    for (const company of companies) {
      company.applied = await userHasApplied(db, userID, company._id);
    }
    return {
      success: true,
      companies: companies,
    };
  } catch (err) {
    console.error(err);
    return {
      success: false,
      message: "An Error Occured. Please Try Again Later",
    };
  }
}

module.exports = {
  emailExists,
  registerUser,
  loginUser,
  getUserID,
  getUser,
  getUserCompany,
  getUserSkills,
  getUserType,
  patchUser,
  getRecommendedCompanies,
  searchCompany,
};
